# esp32mini

````md
# Parrot / Precision Forge — временный порт на ESP32 mini + MAX31855 + ST7789V (общий SPI)

Задача: быстро перенести текущую живую прошивку печи (ESPHome `parrot.yaml`) на **другое железо**:
- MCU: **ESP32 mini** (уточнить ревизию: ESP32-C3 SuperMini / ESP32-S3 mini / “классический” ESP32 mini)
- Термопара: **MAX31855** (SPI, только чтение)
- Дисплей: **ST7789V SPI 240×320**
- Нагрев: **SSR** (GPIO0)

Главный принцип: **не трогаем логику безопасности**, меняем только “железные” секции: `esp32`, `spi`, `sensor`, `display`, `output`.

---

## 1) Итоговая распиновка (как задано)

### SSR
- **GPIO0 — Нагрев SSR**

### SPI (общий для MAX31855 + ST7789V)
- **GPIO2 — SCK**
- **GPIO6 — MOSI (только дисплей)**
- **MAX31855**
  - **GPIO3 — CS**
  - **GPIO4 — MISO**
- **ST7789V**
  - **GPIO5 — DC**
  - **CS**: по умолчанию рекомендуется назначить (см. ниже), но если у вас CS физически не подключен — можно попробовать режим без CS.

> Важно: **GPIO6**. На “классическом” ESP32 (WROOM/WROVER) GPIO6-11 обычно заняты SPI Flash и использовать их нельзя. На ESP32-C3/S3 ситуация другая (GPIO6 может быть доступен). Перед пайкой/прошивкой обязательно уточнить, какой именно “ESP32 mini” у вас.

---

## 2) Минимальный набор проводов, чтобы всё завелось

### Для дисплея ST7789V (минимум)
- VCC → 3V3
- GND → GND
- SCK → GPIO2
- MOSI → GPIO6
- DC → GPIO5
- **CS** → (желательно отдельный GPIO, либо на GND, либо “в воздухе” — зависит от модуля)
- RESET → можно не подключать (если вы сознательно не используете reset_pin)

Рекомендация: если есть возможность, **CS дисплея лучше подключить** (это снижает “чудеса” на шине). Если CS нет физически — тогда в конфиге используем режим без CS (см. ниже).

### Для MAX31855
- VCC → 3V3
- GND → GND
- SCK → GPIO2
- CS → GPIO3
- SO (MISO) → GPIO4

### Для SSR (нагрев)
- IN SSR → GPIO0
- GND SSR → GND

---

## 3) Критические предупреждения по безопасности

### GPIO0 как SSR
GPIO0 — загрузочный (strap) пин на многих ESP32. Если на старте на нём “не то” состояние, плата может уйти в режим прошивки или нестабильно стартовать.

Требования:
1. При boot **SSR должен быть гарантированно выключен**:
   - программно: на `on_boot` выставлять уровень 0.0 на выход SSR (у вас это уже есть — сохранить)
   - аппаратно: предусмотреть подтяжку, чтобы SSR не включался при ресете/плавающих уровнях (обычно pull-down, зависит от схемы входа SSR).
2. Не добавлять логику, которая может включить SSR до проверки датчика/состояния.

---

## 4) Что менять в YAML (пошагово)

### Шаг A — обновить `esp32:` под вашу плату
Если это **ESP32-C3 SuperMini**, обычно используют:
- `platform: ESP32`
- `board: esp32-c3-devkitm-1` (или близкий)
- framework: arduino

Если это другой “mini”, выставить соответствующий `board:`.

Пример (проверить и заменить под вашу плату):
```yaml
esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino
````

### Шаг B — сделать **один** SPI bus для обоих устройств

Удалить второй SPI (если он был), оставить один:

```yaml
spi:
  - id: spi_bus
    clk_pin: GPIO2
    mosi_pin: GPIO6
    miso_pin: GPIO4
```

Пояснение:

* MAX31855 использует SCK+MISO+CS (MOSI ему не нужен, но он на шине допускается)
* ST7789V использует SCK+MOSI+DC (+CS если есть)

### Шаг C — заменить датчик термопары на MAX31855

Удалить/отключить блок `max31856:` и заменить на `max31855:`.

Пример:

```yaml
sensor:
  - platform: max31855
    name: "Kiln Thermocouple"
    id: kiln_temp
    cs_pin: GPIO3
    update_interval: 2s
```

Если у вас в логике ожидается именно `id(kiln_temp)` — сохранить этот `id`.

### Шаг D — перевести дисплей на ST7789V на том же SPI

Использовать `platform: ili9xxx`, `model: ST7789V`, `spi_id: spi_bus`.

Пример (если CS дисплея подключён — лучше так):

```yaml
display:
  - platform: ili9xxx
    model: ST7789V
    spi_id: spi_bus
    id: tft

    cs_pin: GPIOXX      # выбрать свободный GPIO если возможно
    dc_pin: GPIO5
    # reset_pin: GPIOYY  # можно не использовать

    dimensions: 240x320
    rotation: 0         # выставить под вашу ориентацию
    data_rate: 40MHz
    update_interval: 1s
    auto_clear_enabled: false
    lambda: |-
      // ваш существующий UI
```

Если **CS реально не подключён**, пробный вариант:

* убрать `cs_pin` полностью (если компонент позволит)
* или посадить CS дисплея на GND (тогда `cs_pin` можно не задавать)

Важно: поведение “без CS” зависит от конкретного модуля/разводки. Самый стабильный путь — **подключить CS на отдельный GPIO**.

### Шаг E — SSR на GPIO0

Убедиться, что выход SSR использует GPIO0.

Пример:

```yaml
output:
  - platform: slow_pwm
    id: kiln_power_raw
    pin: GPIO0
    period: 15s
```

И в `on_boot` оставить явное выключение SSR:

```yaml
esphome:
  on_boot:
    priority: -10
    then:
      - output.set_level:
          id: kiln_power_raw
          level: 0.0
```

---

## 5) Что НЕ менять (чтобы не сломать проект)

Не трогать:

* логику `heat_allowed`
* аварии / стоп-режимы
* состояние печи (`kiln_state`, `abort_reason`, etc.)
* PID и управление SSR через климат (кроме пина)

Меняем только:

* `esp32:`
* `spi:`
* датчик термопары
* дисплейные пины/модель
* SSR pin

---

## 6) Быстрый чек-лист теста после переноса

1. Boot:

* печь стартует
* SSR выключен по умолчанию (нагрев не включается сам)

2. Термопара:

* `kiln_temp` получает значения (не `nan` после первых 1–2 циклов)

3. Дисплей:

* нет “шума/полос”
* интерфейс рисуется стабильно
* кнопки (если подключены) работают

4. Нагрев:

* при ручном старте/режиме удержания SSR включается только когда разрешено логикой

---

## 7) Если что-то не заводится — типовые причины

* GPIO6 занят флеш-памятью (если это “классический” ESP32) → дисплей/шина не работают
* GPIO0 конфликтует с загрузкой → плата не стартует или стартует через раз
* дисплей без CS на общей шине → “фантомные” проблемы от SPI
* питание дисплея/термопары не 3.3V или плохая земля → мусор на экране/датчик “прыгает”

---

## Контактные параметры (фиксируем для этого порта)

GPIO:

* SSR: GPIO0
* SPI SCK: GPIO2
* MAX31855 CS: GPIO3
* MAX31855 MISO: GPIO4
* ST7789V DC: GPIO5
* SPI MOSI: GPIO6

Дальше: если этот порт окажется стабильным, приводим README основной ветки и пины к единому стандарту.

```
::contentReference[oaicite:0]{index=0}
```
